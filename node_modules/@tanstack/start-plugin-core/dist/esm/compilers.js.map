{"version":3,"file":"compilers.js","sources":["../../src/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport * as t from '@babel/types'\nimport { codeFrameColumns } from '@babel/code-frame'\n\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nexport type CompileStartFrameworkOptions = 'react' | 'solid'\n\nexport function compileStartOutputFactory(\n  framework: CompileStartFrameworkOptions,\n) {\n  return function compileStartOutput(opts: CompileOptions): GeneratorResult {\n    const ast = parseAst(opts)\n\n    const doDce = opts.dce ?? true\n    // find referenced identifiers *before* we transform anything\n    const refIdents = doDce ? findReferencedIdentifiers(ast) : undefined\n\n    babel.traverse(ast, {\n      Program: {\n        enter(programPath) {\n          const identifiers: {\n            createServerRoute: IdentifierConfig\n            createServerFileRoute: IdentifierConfig\n            createServerFn: IdentifierConfig\n            createMiddleware: IdentifierConfig\n            serverOnly: IdentifierConfig\n            clientOnly: IdentifierConfig\n            createIsomorphicFn: IdentifierConfig\n            createServerRootRoute: IdentifierConfig\n          } = {\n            createServerRootRoute: {\n              name: 'createServerRootRoute',\n              handleCallExpression:\n                handleCreateServerFileRouteCallExpressionFactory(\n                  framework,\n                  'createServerRootRoute',\n                ),\n              paths: [],\n            },\n            createServerRoute: {\n              name: 'createServerRoute',\n              handleCallExpression:\n                handleCreateServerFileRouteCallExpressionFactory(\n                  framework,\n                  'createServerRoute',\n                ),\n              paths: [],\n            },\n            createServerFileRoute: {\n              name: 'createServerFileRoute',\n              handleCallExpression:\n                handleCreateServerFileRouteCallExpressionFactory(\n                  framework,\n                  'createServerFileRoute',\n                ),\n              paths: [],\n            },\n            createServerFn: {\n              name: 'createServerFn',\n              handleCallExpression: handleCreateServerFnCallExpression,\n              paths: [],\n            },\n            createMiddleware: {\n              name: 'createMiddleware',\n              handleCallExpression: handleCreateMiddlewareCallExpression,\n              paths: [],\n            },\n            serverOnly: {\n              name: 'serverOnly',\n              handleCallExpression: handleServerOnlyCallExpression,\n              paths: [],\n            },\n            clientOnly: {\n              name: 'clientOnly',\n              handleCallExpression: handleClientOnlyCallExpression,\n              paths: [],\n            },\n            createIsomorphicFn: {\n              name: 'createIsomorphicFn',\n              handleCallExpression: handleCreateIsomorphicFnCallExpression,\n              paths: [],\n            },\n          }\n\n          const identifierKeys = Object.keys(identifiers) as Array<\n            keyof typeof identifiers\n          >\n\n          programPath.traverse({\n            ImportDeclaration: (path) => {\n              if (path.node.source.value !== `@tanstack/${framework}-start`) {\n                return\n              }\n\n              // handle a destructured imports being renamed like \"import { createServerFn as myCreateServerFn } from '@tanstack/react-start';\"\n              path.node.specifiers.forEach((specifier) => {\n                identifierKeys.forEach((identifierKey) => {\n                  const identifier = identifiers[identifierKey]\n\n                  if (\n                    specifier.type === 'ImportSpecifier' &&\n                    specifier.imported.type === 'Identifier'\n                  ) {\n                    if (specifier.imported.name === identifierKey) {\n                      identifier.name = specifier.local.name\n                    }\n                  }\n\n                  // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                  if (specifier.type === 'ImportNamespaceSpecifier') {\n                    identifier.name = `${specifier.local.name}.${identifierKey}`\n                  }\n                })\n              })\n            },\n            CallExpression: (path) => {\n              identifierKeys.forEach((identifierKey) => {\n                // Check to see if the call expression is a call to the\n                // identifiers[identifierKey].name\n                if (\n                  t.isIdentifier(path.node.callee) &&\n                  path.node.callee.name === identifiers[identifierKey].name\n                ) {\n                  // The identifier could be a call to the original function\n                  // in the source code. If this is case, we need to ignore it.\n                  // Check the scope to see if the identifier is a function declaration.\n                  // if it is, then we can ignore it.\n\n                  if (\n                    path.scope.getBinding(identifiers[identifierKey].name)?.path\n                      .node.type === 'FunctionDeclaration'\n                  ) {\n                    return\n                  }\n\n                  return identifiers[identifierKey].paths.push(path)\n                }\n\n                if (t.isMemberExpression(path.node.callee)) {\n                  if (\n                    t.isIdentifier(path.node.callee.object) &&\n                    t.isIdentifier(path.node.callee.property)\n                  ) {\n                    const callname = [\n                      path.node.callee.object.name,\n                      path.node.callee.property.name,\n                    ].join('.')\n\n                    if (callname === identifiers[identifierKey].name) {\n                      identifiers[identifierKey].paths.push(path)\n                    }\n                  }\n                }\n\n                return\n              })\n            },\n          })\n\n          identifierKeys.forEach((identifierKey) => {\n            identifiers[identifierKey].paths.forEach((path) => {\n              identifiers[identifierKey].handleCallExpression(\n                path as babel.NodePath<t.CallExpression>,\n                opts,\n              )\n            })\n          })\n        },\n      },\n    })\n\n    if (doDce) {\n      deadCodeElimination(ast, refIdents)\n    }\n\n    return generateFromAst(ast, {\n      sourceMaps: true,\n      sourceFileName: opts.filename,\n      filename: opts.filename,\n    })\n  }\n}\n\nfunction handleCreateServerFileRouteCallExpressionFactory(\n  factory: CompileStartFrameworkOptions,\n  method:\n    | 'createServerFileRoute'\n    | 'createServerRoute'\n    | 'createServerRootRoute',\n) {\n  return function handleCreateServerFileRouteCallExpression(\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) {\n    const PACKAGES = { start: `@tanstack/${factory}-start/server` }\n\n    let highestParent: babel.NodePath<any> = path\n\n    while (highestParent.parentPath && !highestParent.parentPath.isProgram()) {\n      highestParent = highestParent.parentPath\n    }\n\n    const programPath = highestParent.parentPath as babel.NodePath<t.Program>\n\n    // If we're on the client, remove the entire variable\n    if (opts.env === 'client') {\n      // console.debug('createServerFileRoute -> manifest:\\n', manifest)\n      highestParent.remove()\n      return\n    }\n\n    let isCreateServerFileRouteImported = false as boolean\n\n    programPath.traverse({\n      ImportDeclaration(importPath) {\n        const importSource = importPath.node.source.value\n        if (importSource === PACKAGES.start) {\n          const specifiers = importPath.node.specifiers\n          isCreateServerFileRouteImported ||= specifiers.some((specifier) => {\n            return (\n              t.isImportSpecifier(specifier) &&\n              t.isIdentifier(specifier.imported) &&\n              specifier.imported.name === method\n            )\n          })\n        }\n      },\n    })\n\n    if (!isCreateServerFileRouteImported) {\n      const importDeclaration = t.importDeclaration(\n        [t.importSpecifier(t.identifier(method), t.identifier(method))],\n        t.stringLiteral(PACKAGES.start),\n      )\n      programPath.node.body.unshift(importDeclaration)\n    }\n  }\n}\n\n// build these once and reuse them\nexport const handleServerOnlyCallExpression =\n  buildEnvOnlyCallExpressionHandler('server')\nexport const handleClientOnlyCallExpression =\n  buildEnvOnlyCallExpressionHandler('client')\n\nexport type CompileOptions = ParseAstOptions & {\n  env: 'server' | 'client'\n  dce?: boolean\n  filename: string\n}\n\nexport type IdentifierConfig = {\n  name: string\n  handleCallExpression: (\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) => void\n  paths: Array<babel.NodePath>\n}\n\nexport function handleCreateServerFnCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: CompileOptions,\n) {\n  // The function is the 'fn' property of the object passed to createServerFn\n\n  // const firstArg = path.node.arguments[0]\n  // if (t.isObjectExpression(firstArg)) {\n  //   // Was called with some options\n  // }\n\n  // Traverse the member expression and find the call expressions for\n  // the validator, handler, and middleware methods. Check to make sure they\n  // are children of the createServerFn call expression.\n\n  const calledOptions = path.node.arguments[0]\n    ? (path.get('arguments.0') as babel.NodePath<t.ObjectExpression>)\n    : null\n\n  const shouldValidateClient = !!calledOptions?.node.properties.find((prop) => {\n    return (\n      t.isObjectProperty(prop) &&\n      t.isIdentifier(prop.key) &&\n      prop.key.name === 'validateClient' &&\n      t.isBooleanLiteral(prop.value) &&\n      prop.value.value === true\n    )\n  })\n\n  const callExpressionPaths = {\n    middleware: null as babel.NodePath<t.CallExpression> | null,\n    validator: null as babel.NodePath<t.CallExpression> | null,\n    handler: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createServerFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  // Check if the call is assigned to a variable\n  if (!rootCallExpression.parentPath.isVariableDeclarator()) {\n    throw new Error('createServerFn must be assigned to a variable!')\n  }\n\n  // Get the identifier name of the variable\n  const variableDeclarator = rootCallExpression.parentPath.node\n  const existingVariableName = (variableDeclarator.id as t.Identifier).name\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (callExpressionPaths.validator) {\n    const innerInputExpression = callExpressionPaths.validator.node.arguments[0]\n\n    if (!innerInputExpression) {\n      throw new Error(\n        'createServerFn().validator() must be called with a validator!',\n      )\n    }\n\n    // If we're on the client, and we're not validating the client, remove the validator call expression\n    if (\n      opts.env === 'client' &&\n      !shouldValidateClient &&\n      t.isMemberExpression(callExpressionPaths.validator.node.callee)\n    ) {\n      callExpressionPaths.validator.replaceWith(\n        callExpressionPaths.validator.node.callee.object,\n      )\n    }\n  }\n\n  // First, we need to move the handler function to a nested function call\n  // that is applied to the arguments passed to the server function.\n\n  const handlerFnPath = callExpressionPaths.handler?.get(\n    'arguments.0',\n  ) as babel.NodePath<any>\n\n  if (!callExpressionPaths.handler || !handlerFnPath.node) {\n    throw codeFrameError(\n      opts.code,\n      path.node.callee.loc!,\n      `createServerFn must be called with a \"handler\" property!`,\n    )\n  }\n\n  const handlerFn = handlerFnPath.node\n\n  // So, the way we do this is we give the handler function a way\n  // to access the serverFn ctx on the server via function scope.\n  // The 'use server' extracted function will be called with the\n  // payload from the client, then use the scoped serverFn ctx\n  // to execute the handler function.\n  // This way, we can do things like data and middleware validation\n  // in the __execute function without having to AST transform the\n  // handler function too much itself.\n\n  // .handler((optsOut, ctx) => {\n  //   return ((optsIn) => {\n  //     'use server'\n  //     ctx.__execute(handlerFn, optsIn)\n  //   })(optsOut)\n  // })\n\n  // If the handler function is an identifier and we're on the client, we need to\n  // remove the bound function from the file.\n  // If we're on the server, you can leave it, since it will get referenced\n  // as a second argument.\n\n  if (t.isIdentifier(handlerFn)) {\n    if (opts.env === 'client') {\n      // Find the binding for the handler function\n      const binding = handlerFnPath.scope.getBinding(handlerFn.name)\n      // Remove it\n      if (binding) {\n        binding.path.remove()\n      }\n    }\n    // If the env is server, just leave it alone\n  }\n\n  handlerFnPath.replaceWith(\n    t.arrowFunctionExpression(\n      [t.identifier('opts'), t.identifier('signal')],\n      t.blockStatement(\n        // Everything in here is server-only, since the client\n        // will strip out anything in the 'use server' directive.\n        [\n          t.returnStatement(\n            t.callExpression(\n              t.identifier(`${existingVariableName}.__executeServer`),\n              [t.identifier('opts'), t.identifier('signal')],\n            ),\n          ),\n        ],\n        [t.directive(t.directiveLiteral('use server'))],\n      ),\n    ),\n  )\n\n  if (opts.env === 'server') {\n    callExpressionPaths.handler.node.arguments.push(handlerFn)\n  }\n}\n\nexport function handleCreateMiddlewareCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: CompileOptions,\n) {\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createMiddleware call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  const callExpressionPaths = {\n    middleware: null as babel.NodePath<t.CallExpression> | null,\n    validator: null as babel.NodePath<t.CallExpression> | null,\n    client: null as babel.NodePath<t.CallExpression> | null,\n    server: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (callExpressionPaths.validator) {\n    const innerInputExpression = callExpressionPaths.validator.node.arguments[0]\n\n    if (!innerInputExpression) {\n      throw new Error(\n        'createMiddleware().validator() must be called with a validator!',\n      )\n    }\n\n    // If we're on the client, remove the validator call expression\n    if (opts.env === 'client') {\n      if (t.isMemberExpression(callExpressionPaths.validator.node.callee)) {\n        callExpressionPaths.validator.replaceWith(\n          callExpressionPaths.validator.node.callee.object,\n        )\n      }\n    }\n  }\n\n  const serverFnPath = callExpressionPaths.server?.get(\n    'arguments.0',\n  ) as babel.NodePath<any>\n\n  if (\n    callExpressionPaths.server &&\n    serverFnPath.node &&\n    opts.env === 'client'\n  ) {\n    // If we're on the client, remove the server call expression\n    if (t.isMemberExpression(callExpressionPaths.server.node.callee)) {\n      callExpressionPaths.server.replaceWith(\n        callExpressionPaths.server.node.callee.object,\n      )\n    }\n  }\n}\n\nfunction buildEnvOnlyCallExpressionHandler(env: 'client' | 'server') {\n  return function envOnlyCallExpressionHandler(\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) {\n    // if (debug)\n    //   console.info(`Handling ${env}Only call expression:`, path.toString())\n\n    const isEnvMatch =\n      env === 'client' ? opts.env === 'client' : opts.env === 'server'\n\n    if (isEnvMatch) {\n      // extract the inner function from the call expression\n      const innerInputExpression = path.node.arguments[0]\n\n      if (!t.isExpression(innerInputExpression)) {\n        throw new Error(\n          `${env}Only() functions must be called with a function!`,\n        )\n      }\n\n      path.replaceWith(innerInputExpression)\n      return\n    }\n\n    // If we're on the wrong environment, replace the call expression\n    // with a function that always throws an error.\n    path.replaceWith(\n      t.arrowFunctionExpression(\n        [],\n        t.blockStatement([\n          t.throwStatement(\n            t.newExpression(t.identifier('Error'), [\n              t.stringLiteral(\n                `${env}Only() functions can only be called on the ${env}!`,\n              ),\n            ]),\n          ),\n        ]),\n      ),\n    )\n  }\n}\n\nexport function handleCreateIsomorphicFnCallExpression(\n  path: babel.NodePath<t.CallExpression>,\n  opts: CompileOptions,\n) {\n  const rootCallExpression = getRootCallExpression(path)\n\n  // if (debug)\n  //   console.info(\n  //     'Handling createIsomorphicFn call expression:',\n  //     rootCallExpression.toString(),\n  //   )\n\n  const callExpressionPaths = {\n    client: null as babel.NodePath<t.CallExpression> | null,\n    server: null as babel.NodePath<t.CallExpression> | null,\n  }\n\n  const validMethods = Object.keys(callExpressionPaths)\n\n  rootCallExpression.traverse({\n    MemberExpression(memberExpressionPath) {\n      if (t.isIdentifier(memberExpressionPath.node.property)) {\n        const name = memberExpressionPath.node.property\n          .name as keyof typeof callExpressionPaths\n\n        if (\n          validMethods.includes(name) &&\n          memberExpressionPath.parentPath.isCallExpression()\n        ) {\n          callExpressionPaths[name] = memberExpressionPath.parentPath\n        }\n      }\n    },\n  })\n\n  if (\n    validMethods.every(\n      (method) =>\n        !callExpressionPaths[method as keyof typeof callExpressionPaths],\n    )\n  ) {\n    const variableId = rootCallExpression.parentPath.isVariableDeclarator()\n      ? rootCallExpression.parentPath.node.id\n      : null\n    console.warn(\n      'createIsomorphicFn called without a client or server implementation!',\n      'This will result in a no-op function.',\n      'Variable name:',\n      t.isIdentifier(variableId) ? variableId.name : 'unknown',\n    )\n  }\n\n  const envCallExpression = callExpressionPaths[opts.env]\n\n  if (!envCallExpression) {\n    // if we don't have an implementation for this environment, default to a no-op\n    rootCallExpression.replaceWith(\n      t.arrowFunctionExpression([], t.blockStatement([])),\n    )\n    return\n  }\n\n  const innerInputExpression = envCallExpression.node.arguments[0]\n\n  if (!t.isExpression(innerInputExpression)) {\n    throw new Error(\n      `createIsomorphicFn().${opts.env}(func) must be called with a function!`,\n    )\n  }\n\n  rootCallExpression.replaceWith(innerInputExpression)\n}\n\nexport function getRootCallExpression(path: babel.NodePath<t.CallExpression>) {\n  // Find the highest callExpression parent\n  let rootCallExpression: babel.NodePath<t.CallExpression> = path\n\n  // Traverse up the chain of CallExpressions\n  while (rootCallExpression.parentPath.isMemberExpression()) {\n    const parent = rootCallExpression.parentPath\n    if (parent.parentPath.isCallExpression()) {\n      rootCallExpression = parent.parentPath\n    }\n  }\n\n  return rootCallExpression\n}\n\nfunction codeFrameError(\n  code: string,\n  loc: {\n    start: { line: number; column: number }\n    end: { line: number; column: number }\n  },\n  message: string,\n) {\n  const frame = codeFrameColumns(\n    code,\n    {\n      start: loc.start,\n      end: loc.end,\n    },\n    {\n      highlightCode: true,\n      message,\n    },\n  )\n\n  return new Error(frame)\n}\n"],"names":[],"mappings":"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"}