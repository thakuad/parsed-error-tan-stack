{"version":3,"file":"createStartHandler.js","sources":["../../src/createStartHandler.ts"],"sourcesContent":["import { createMemoryHistory } from '@tanstack/history'\nimport {\n  flattenMiddlewares,\n  json,\n  mergeHeaders,\n} from '@tanstack/start-client-core'\nimport {\n  getMatchedRoutes,\n  isRedirect,\n  isResolvedRedirect,\n  joinPaths,\n  processRouteTree,\n  trimPath,\n} from '@tanstack/router-core'\nimport { attachRouterServerSsrUtils } from '@tanstack/router-core/ssr/server'\nimport { getResponseHeaders, requestHandler } from './h3'\nimport { getStartManifest } from './router-manifest'\nimport { handleServerAction } from './server-functions-handler'\nimport { VIRTUAL_MODULES } from './virtual-modules'\nimport { loadVirtualModule } from './loadVirtualModule'\nimport type {\n  AnyServerRouteWithTypes,\n  ServerRouteMethodHandlerFn,\n} from './serverRoute'\nimport type { RequestHandler } from './h3'\nimport type {\n  AnyRoute,\n  AnyRouter,\n  Awaitable,\n  Manifest,\n  ProcessRouteTreeResult,\n} from '@tanstack/router-core'\nimport type { HandlerCallback } from '@tanstack/router-core/ssr/server'\n\ntype TODO = any\n\nexport type CustomizeStartHandler<TRouter extends AnyRouter> = (\n  cb: HandlerCallback<TRouter>,\n) => RequestHandler\n\nfunction getStartResponseHeaders(opts: { router: AnyRouter }) {\n  const headers = mergeHeaders(\n    getResponseHeaders(),\n    {\n      'Content-Type': 'text/html; charset=UTF-8',\n    },\n    ...opts.router.state.matches.map((match) => {\n      return match.headers\n    }),\n  )\n  return headers\n}\n\nexport function createStartHandler<TRouter extends AnyRouter>({\n  createRouter,\n}: {\n  createRouter: () => Awaitable<TRouter>\n}): CustomizeStartHandler<TRouter> {\n  let routeTreeModule: {\n    serverRouteTree: AnyServerRouteWithTypes | undefined\n    routeTree: AnyRoute | undefined\n  } | null = null\n  let startRoutesManifest: Manifest | null = null\n  let processedServerRouteTree:\n    | ProcessRouteTreeResult<AnyServerRouteWithTypes>\n    | undefined = undefined\n\n  return (cb) => {\n    const originalFetch = globalThis.fetch\n\n    const startRequestResolver: RequestHandler = async ({ request }) => {\n      // Patching fetch function to use our request resolver\n      // if the input starts with `/` which is a common pattern for\n      // client-side routing.\n      // When we encounter similar requests, we can assume that the\n      // user wants to use the same origin as the current request.\n      globalThis.fetch = async function (input, init) {\n        function resolve(url: URL, requestOptions: RequestInit | undefined) {\n          const fetchRequest = new Request(url, requestOptions)\n          return startRequestResolver({ request: fetchRequest })\n        }\n\n        function getOrigin() {\n          return (\n            request.headers.get('Origin') ||\n            request.headers.get('Referer') ||\n            'http://localhost'\n          )\n        }\n\n        if (typeof input === 'string' && input.startsWith('/')) {\n          // e.g: fetch('/api/data')\n          const url = new URL(input, getOrigin())\n          return resolve(url, init)\n        } else if (\n          typeof input === 'object' &&\n          'url' in input &&\n          typeof input.url === 'string' &&\n          input.url.startsWith('/')\n        ) {\n          // e.g: fetch(new Request('/api/data'))\n          const url = new URL(input.url, getOrigin())\n          return resolve(url, init)\n        }\n\n        // If not, it should just use the original fetch\n        return originalFetch(input, init)\n      }\n\n      const url = new URL(request.url)\n      const href = decodeURIComponent(url.href.replace(url.origin, ''))\n\n      const APP_BASE = process.env.TSS_APP_BASE || '/'\n\n      // TODO how does this work with base path? does the router need to be configured the same as APP_BASE?\n      const router = await createRouter()\n      // Create a history for the client-side router\n      const history = createMemoryHistory({\n        initialEntries: [href],\n      })\n\n      // Update the client-side router with the history\n      router.update({\n        history,\n        isShell: process.env.TSS_SPA_MODE === 'true',\n      })\n\n      const response = await (async () => {\n        try {\n          if (!process.env.TSS_SERVER_FN_BASE) {\n            throw new Error(\n              'tanstack/start-server-core: TSS_SERVER_FN_BASE must be defined in your environment for createStartHandler()',\n            )\n          }\n\n          // First, let's attempt to handle server functions\n          // Add trailing slash to sanitise user defined TSS_SERVER_FN_BASE\n          const serverFnBase = joinPaths([\n            APP_BASE,\n            trimPath(process.env.TSS_SERVER_FN_BASE),\n            '/',\n          ])\n          if (href.startsWith(serverFnBase)) {\n            return await handleServerAction({ request })\n          }\n\n          if (routeTreeModule === null) {\n            try {\n              routeTreeModule = await loadVirtualModule(\n                VIRTUAL_MODULES.routeTree,\n              )\n              if (routeTreeModule.serverRouteTree) {\n                processedServerRouteTree =\n                  processRouteTree<AnyServerRouteWithTypes>({\n                    routeTree: routeTreeModule.serverRouteTree,\n                    initRoute: (route, i) => {\n                      route.init({\n                        originalIndex: i,\n                      })\n                    },\n                  })\n              }\n            } catch (e) {\n              console.log(e)\n            }\n          }\n\n          async function executeRouter() {\n            const requestAcceptHeader = request.headers.get('Accept') || '*/*'\n            const splitRequestAcceptHeader = requestAcceptHeader.split(',')\n\n            const supportedMimeTypes = ['*/*', 'text/html']\n            const isRouterAcceptSupported = supportedMimeTypes.some(\n              (mimeType) =>\n                splitRequestAcceptHeader.some((acceptedMimeType) =>\n                  acceptedMimeType.trim().startsWith(mimeType),\n                ),\n            )\n\n            if (!isRouterAcceptSupported) {\n              return json(\n                {\n                  error: 'Only HTML requests are supported here',\n                },\n                {\n                  status: 500,\n                },\n              )\n            }\n\n            // if the startRoutesManifest is not loaded yet, load it once\n            if (startRoutesManifest === null) {\n              startRoutesManifest = await getStartManifest({\n                basePath: APP_BASE,\n              })\n            }\n\n            // Attach the server-side SSR utils to the client-side router\n            attachRouterServerSsrUtils(router, startRoutesManifest)\n\n            await router.load()\n\n            // If there was a redirect, skip rendering the page at all\n            if (router.state.redirect) {\n              return router.state.redirect\n            }\n\n            await router.serverSsr!.dehydrate()\n\n            const responseHeaders = getStartResponseHeaders({ router })\n            const response = await cb({\n              request,\n              router,\n              responseHeaders,\n            })\n\n            return response\n          }\n\n          // If we have a server route tree, then we try matching to see if we have a\n          // server route that matches the request.\n          if (processedServerRouteTree) {\n            const [_matchedRoutes, response] = await handleServerRoutes({\n              processedServerRouteTree,\n              router,\n              request,\n              basePath: APP_BASE,\n              executeRouter,\n            })\n\n            if (response) return response\n          }\n\n          // Server Routes did not produce a response, so fallback to normal SSR matching using the router\n          const routerResponse = await executeRouter()\n          return routerResponse\n        } catch (err) {\n          if (err instanceof Response) {\n            return err\n          }\n\n          throw err\n        }\n      })()\n\n      if (isRedirect(response)) {\n        if (isResolvedRedirect(response)) {\n          if (request.headers.get('x-tsr-redirect') === 'manual') {\n            return json(\n              {\n                ...response.options,\n                isSerializedRedirect: true,\n              },\n              {\n                headers: response.headers,\n              },\n            )\n          }\n          return response\n        }\n        if (\n          response.options.to &&\n          typeof response.options.to === 'string' &&\n          !response.options.to.startsWith('/')\n        ) {\n          throw new Error(\n            `Server side redirects must use absolute paths via the 'href' or 'to' options. Received: ${JSON.stringify(response.options)}`,\n          )\n        }\n\n        if (\n          ['params', 'search', 'hash'].some(\n            (d) => typeof (response.options as any)[d] === 'function',\n          )\n        ) {\n          throw new Error(\n            `Server side redirects must use static search, params, and hash values and do not support functional values. Received functional values for: ${Object.keys(\n              response.options,\n            )\n              .filter((d) => typeof (response.options as any)[d] === 'function')\n              .map((d) => `\"${d}\"`)\n              .join(', ')}`,\n          )\n        }\n\n        const redirect = router.resolveRedirect(response)\n\n        if (request.headers.get('x-tsr-redirect') === 'manual') {\n          return json(\n            {\n              ...response.options,\n              isSerializedRedirect: true,\n            },\n            {\n              headers: response.headers,\n            },\n          )\n        }\n\n        return redirect\n      }\n\n      return response\n    }\n\n    return requestHandler(startRequestResolver)\n  }\n}\n\nasync function handleServerRoutes(opts: {\n  router: AnyRouter\n  processedServerRouteTree: ProcessRouteTreeResult<AnyServerRouteWithTypes>\n  request: Request\n  basePath: string\n  executeRouter: () => Promise<Response>\n}) {\n  const url = new URL(opts.request.url)\n  const pathname = url.pathname\n\n  const serverTreeResult = getMatchedRoutes<AnyServerRouteWithTypes>({\n    pathname,\n    basepath: opts.basePath,\n    caseSensitive: true,\n    routesByPath: opts.processedServerRouteTree.routesByPath,\n    routesById: opts.processedServerRouteTree.routesById,\n    flatRoutes: opts.processedServerRouteTree.flatRoutes,\n  })\n\n  const routeTreeResult = opts.router.getMatchedRoutes(pathname, undefined)\n\n  let response: Response | undefined\n  let matchedRoutes: Array<AnyServerRouteWithTypes> = []\n  matchedRoutes = serverTreeResult.matchedRoutes\n  // check if the app route tree found a match that is deeper than the server route tree\n  if (routeTreeResult.foundRoute) {\n    if (\n      serverTreeResult.matchedRoutes.length <\n      routeTreeResult.matchedRoutes.length\n    ) {\n      const closestCommon = [...routeTreeResult.matchedRoutes]\n        .reverse()\n        .find((r) => {\n          return opts.processedServerRouteTree.routesById[r.id] !== undefined\n        })\n      if (closestCommon) {\n        // walk up the tree and collect all parents\n        let routeId = closestCommon.id\n        matchedRoutes = []\n        do {\n          const route = opts.processedServerRouteTree.routesById[routeId]\n          if (!route) {\n            break\n          }\n          matchedRoutes.push(route)\n          routeId = route.parentRoute?.id\n        } while (routeId)\n\n        matchedRoutes.reverse()\n      }\n    }\n  }\n\n  if (matchedRoutes.length) {\n    // We've found a server route that (partially) matches the request, so we can call it.\n    // TODO: Error handling? What happens when its `throw redirect()` vs `throw new Error()`?\n\n    const middlewares = flattenMiddlewares(\n      matchedRoutes.flatMap((r) => r.options.middleware).filter(Boolean),\n    ).map((d) => d.options.server)\n\n    if (serverTreeResult.foundRoute?.options.methods) {\n      const method = Object.keys(\n        serverTreeResult.foundRoute.options.methods,\n      ).find(\n        (method) => method.toLowerCase() === opts.request.method.toLowerCase(),\n      )\n\n      if (method) {\n        const handler = serverTreeResult.foundRoute.options.methods[method]\n        if (handler) {\n          if (typeof handler === 'function') {\n            middlewares.push(handlerToMiddleware(handler) as TODO)\n          } else {\n            if (\n              handler._options.middlewares &&\n              handler._options.middlewares.length\n            ) {\n              middlewares.push(\n                ...flattenMiddlewares(handler._options.middlewares as any).map(\n                  (d) => d.options.server,\n                ),\n              )\n            }\n            if (handler._options.handler) {\n              middlewares.push(handlerToMiddleware(handler._options.handler))\n            }\n          }\n        }\n      }\n    }\n\n    // eventually, execute the router\n    middlewares.push(handlerToMiddleware(opts.executeRouter))\n\n    // TODO: This is starting to feel too much like a server function\n    // Do generalize the existing middleware execution? Or do we need to\n    // build a new middleware execution system for server routes?\n    const ctx = await executeMiddleware(middlewares, {\n      request: opts.request,\n      context: {},\n      params: serverTreeResult.routeParams,\n      pathname,\n    })\n\n    response = ctx.response\n  }\n\n  // We return the matched routes too so if\n  // the app router happens to match the same path,\n  // it can use any request middleware from server routes\n  return [matchedRoutes, response] as const\n}\n\nfunction handlerToMiddleware(\n  handler: ServerRouteMethodHandlerFn<\n    AnyServerRouteWithTypes,\n    any,\n    any,\n    any,\n    any\n  >,\n) {\n  return async ({ next: _next, ...rest }: TODO) => {\n    const response = await handler(rest)\n    if (response) {\n      return { response }\n    }\n    return _next(rest)\n  }\n}\n\nfunction executeMiddleware(middlewares: TODO, ctx: TODO) {\n  let index = -1\n\n  const next = async (ctx: TODO) => {\n    index++\n    const middleware = middlewares[index]\n    if (!middleware) return ctx\n\n    const result = await middleware({\n      ...ctx,\n      // Allow the middleware to call the next middleware in the chain\n      next: async (nextCtx: TODO) => {\n        // Allow the caller to extend the context for the next middleware\n        const nextResult = await next({\n          ...ctx,\n          ...nextCtx,\n          context: {\n            ...ctx.context,\n            ...(nextCtx?.context || {}),\n          },\n        })\n\n        // Merge the result into the context\\\n        return Object.assign(ctx, handleCtxResult(nextResult))\n      },\n      // Allow the middleware result to extend the return context\n    }).catch((err: TODO) => {\n      if (isSpecialResponse(err)) {\n        return {\n          response: err,\n        }\n      }\n\n      throw err\n    })\n\n    // Merge the middleware result into the context, just in case it\n    // returns a partial context\n    return Object.assign(ctx, handleCtxResult(result))\n  }\n\n  return handleCtxResult(next(ctx))\n}\n\nfunction handleCtxResult(result: TODO) {\n  if (isSpecialResponse(result)) {\n    return {\n      response: result,\n    }\n  }\n\n  return result\n}\n\nfunction isSpecialResponse(err: TODO) {\n  return isResponse(err) || isRedirect(err)\n}\n\nfunction isResponse(response: Response): response is Response {\n  return response instanceof Response\n}\n"],"names":["url","response","method","ctx"],"mappings":"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"}