{"version":3,"file":"queue.js","sources":["../../../src/nitro-plugin/queue.ts"],"sourcesContent":["interface PoolConfig {\n  concurrency?: number\n  started?: boolean\n  tasks?: Array<() => Promise<any>>\n}\n\nconst defaultConfig: PoolConfig = {\n  concurrency: 5,\n  started: false,\n  tasks: [],\n}\n\nexport class Queue<T> {\n  private onSettles: Array<(res: any, error: any) => void> = []\n  private onErrors: Array<(error: any, task: () => Promise<any>) => void> = []\n  private onSuccesses: Array<(result: any, task: () => Promise<any>) => void> =\n    []\n  private running: boolean\n  private active: Array<() => Promise<any>> = []\n  private pending: Array<() => Promise<any>>\n  private currentConcurrency: number\n\n  constructor(config: PoolConfig = defaultConfig) {\n    const { concurrency, started, tasks } = {\n      ...defaultConfig,\n      ...config,\n    }\n    this.running = started!\n    this.pending = tasks as Array<() => Promise<any>>\n    this.currentConcurrency = concurrency!\n  }\n\n  private tick() {\n    if (!this.running) {\n      return\n    }\n    while (\n      this.active.length < this.currentConcurrency &&\n      this.pending.length\n    ) {\n      const nextFn = this.pending.shift()\n      if (!nextFn) {\n        throw new Error('Found task that is not a function')\n      }\n      this.active.push(nextFn)\n      ;(async () => {\n        let success = false\n        let res!: T\n        let error: any\n        try {\n          res = await nextFn()\n          success = true\n        } catch (e) {\n          error = e\n        }\n        this.active = this.active.filter((d) => d !== nextFn)\n        if (success) {\n          this.onSuccesses.forEach((d) => d(res, nextFn))\n        } else {\n          this.onErrors.forEach((d) => d(error, nextFn))\n        }\n        this.onSettles.forEach((d) => d(res, error))\n        this.tick()\n      })()\n    }\n  }\n\n  add(fn: () => Promise<T> | T, { priority }: { priority?: boolean } = {}) {\n    return new Promise<any>((resolve, reject) => {\n      const task = () =>\n        Promise.resolve(fn())\n          .then((res) => {\n            resolve(res)\n            return res\n          })\n          .catch((err) => {\n            reject(err)\n            throw err\n          })\n      if (priority) {\n        this.pending.unshift(task)\n      } else {\n        this.pending.push(task)\n      }\n      this.tick()\n    })\n  }\n\n  throttle(n: number) {\n    this.currentConcurrency = n\n  }\n\n  onSettled(cb: () => void) {\n    this.onSettles.push(cb)\n    return () => {\n      this.onSettles = this.onSettles.filter((d) => d !== cb)\n    }\n  }\n\n  onError(cb: (error: any, task: () => Promise<any>) => void) {\n    this.onErrors.push(cb)\n    return () => {\n      this.onErrors = this.onErrors.filter((d) => d !== cb)\n    }\n  }\n\n  onSuccess(cb: (result: any, task: () => Promise<any>) => void) {\n    this.onSuccesses.push(cb)\n    return () => {\n      this.onSuccesses = this.onSuccesses.filter((d) => d !== cb)\n    }\n  }\n\n  stop() {\n    this.running = false\n  }\n\n  start() {\n    this.running = true\n    this.tick()\n    return new Promise<void>((resolve) => {\n      this.onSettled(() => {\n        if (this.isSettled()) {\n          resolve()\n        }\n      })\n    })\n  }\n\n  clear() {\n    this.pending = []\n  }\n\n  getActive() {\n    return this.active\n  }\n\n  getPending() {\n    return this.pending\n  }\n\n  getAll() {\n    return [...this.active, ...this.pending]\n  }\n\n  isRunning() {\n    return this.running\n  }\n\n  isSettled() {\n    return !this.active.length && !this.pending.length\n  }\n}\n"],"names":[],"mappings":";;;AAMA,MAAM,gBAA4B;AAAA,EAChC,aAAa;AAAA,EACb,SAAS;AAAA,EACT,OAAO,CAAA;AACT;AAEO,MAAM,MAAS;AAAA,EAUpB,YAAY,SAAqB,eAAe;AATxC,qCAAmD,CAAC;AACpD,oCAAkE,CAAC;AACnE,uCACN,CAAC;AACK;AACA,kCAAoC,CAAC;AACrC;AACA;AAGN,UAAM,EAAE,aAAa,SAAS,UAAU;AAAA,MACtC,GAAG;AAAA,MACH,GAAG;AAAA,IACL;AACA,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,qBAAqB;AAAA,EAAA;AAAA,EAGpB,OAAO;AACT,QAAA,CAAC,KAAK,SAAS;AACjB;AAAA,IAAA;AAEF,WACE,KAAK,OAAO,SAAS,KAAK,sBAC1B,KAAK,QAAQ,QACb;AACM,YAAA,SAAS,KAAK,QAAQ,MAAM;AAClC,UAAI,CAAC,QAAQ;AACL,cAAA,IAAI,MAAM,mCAAmC;AAAA,MAAA;AAEhD,WAAA,OAAO,KAAK,MAAM;AACtB,OAAC,YAAY;AACZ,YAAI,UAAU;AACV,YAAA;AACA,YAAA;AACA,YAAA;AACF,gBAAM,MAAM,OAAO;AACT,oBAAA;AAAA,iBACH,GAAG;AACF,kBAAA;AAAA,QAAA;AAEV,aAAK,SAAS,KAAK,OAAO,OAAO,CAAC,MAAM,MAAM,MAAM;AACpD,YAAI,SAAS;AACX,eAAK,YAAY,QAAQ,CAAC,MAAM,EAAE,KAAK,MAAM,CAAC;AAAA,QAAA,OACzC;AACL,eAAK,SAAS,QAAQ,CAAC,MAAM,EAAE,OAAO,MAAM,CAAC;AAAA,QAAA;AAE/C,aAAK,UAAU,QAAQ,CAAC,MAAM,EAAE,KAAK,KAAK,CAAC;AAC3C,aAAK,KAAK;AAAA,MAAA,GACT;AAAA,IAAA;AAAA,EACL;AAAA,EAGF,IAAI,IAA0B,EAAE,SAAS,IAA4B,CAAA,GAAI;AACvE,WAAO,IAAI,QAAa,CAAC,SAAS,WAAW;AACrC,YAAA,OAAO,MACX,QAAQ,QAAQ,IAAI,EACjB,KAAK,CAAC,QAAQ;AACb,gBAAQ,GAAG;AACJ,eAAA;AAAA,MAAA,CACR,EACA,MAAM,CAAC,QAAQ;AACd,eAAO,GAAG;AACJ,cAAA;AAAA,MAAA,CACP;AACL,UAAI,UAAU;AACP,aAAA,QAAQ,QAAQ,IAAI;AAAA,MAAA,OACpB;AACA,aAAA,QAAQ,KAAK,IAAI;AAAA,MAAA;AAExB,WAAK,KAAK;AAAA,IAAA,CACX;AAAA,EAAA;AAAA,EAGH,SAAS,GAAW;AAClB,SAAK,qBAAqB;AAAA,EAAA;AAAA,EAG5B,UAAU,IAAgB;AACnB,SAAA,UAAU,KAAK,EAAE;AACtB,WAAO,MAAM;AACX,WAAK,YAAY,KAAK,UAAU,OAAO,CAAC,MAAM,MAAM,EAAE;AAAA,IACxD;AAAA,EAAA;AAAA,EAGF,QAAQ,IAAoD;AACrD,SAAA,SAAS,KAAK,EAAE;AACrB,WAAO,MAAM;AACX,WAAK,WAAW,KAAK,SAAS,OAAO,CAAC,MAAM,MAAM,EAAE;AAAA,IACtD;AAAA,EAAA;AAAA,EAGF,UAAU,IAAqD;AACxD,SAAA,YAAY,KAAK,EAAE;AACxB,WAAO,MAAM;AACX,WAAK,cAAc,KAAK,YAAY,OAAO,CAAC,MAAM,MAAM,EAAE;AAAA,IAC5D;AAAA,EAAA;AAAA,EAGF,OAAO;AACL,SAAK,UAAU;AAAA,EAAA;AAAA,EAGjB,QAAQ;AACN,SAAK,UAAU;AACf,SAAK,KAAK;AACH,WAAA,IAAI,QAAc,CAAC,YAAY;AACpC,WAAK,UAAU,MAAM;AACf,YAAA,KAAK,aAAa;AACZ,kBAAA;AAAA,QAAA;AAAA,MACV,CACD;AAAA,IAAA,CACF;AAAA,EAAA;AAAA,EAGH,QAAQ;AACN,SAAK,UAAU,CAAC;AAAA,EAAA;AAAA,EAGlB,YAAY;AACV,WAAO,KAAK;AAAA,EAAA;AAAA,EAGd,aAAa;AACX,WAAO,KAAK;AAAA,EAAA;AAAA,EAGd,SAAS;AACP,WAAO,CAAC,GAAG,KAAK,QAAQ,GAAG,KAAK,OAAO;AAAA,EAAA;AAAA,EAGzC,YAAY;AACV,WAAO,KAAK;AAAA,EAAA;AAAA,EAGd,YAAY;AACV,WAAO,CAAC,KAAK,OAAO,UAAU,CAAC,KAAK,QAAQ;AAAA,EAAA;AAEhD;"}