{"version":3,"file":"plugin.js","sources":["../../../src/start-manifest-plugin/plugin.ts"],"sourcesContent":["import { joinURL } from 'ufo'\nimport { rootRouteId } from '@tanstack/router-core'\nimport { VIRTUAL_MODULES } from '@tanstack/start-server-core'\nimport { tsrSplit } from '@tanstack/router-plugin'\nimport { resolveViteId } from '../utils'\nimport type { PluginOption, ResolvedConfig, Rollup } from 'vite'\nimport type { RouterManagedTag } from '@tanstack/router-core'\n\nexport const getCSSRecursively = (\n  chunk: Rollup.OutputChunk,\n  chunksByFileName: Map<string, Rollup.OutputChunk>,\n  basePath: string,\n) => {\n  const result: Array<RouterManagedTag> = []\n\n  // Get all css imports from the file\n  for (const cssFile of chunk.viteMetadata?.importedCss ?? []) {\n    result.push({\n      tag: 'link',\n      attrs: {\n        rel: 'stylesheet',\n        href: joinURL(basePath, cssFile),\n        type: 'text/css',\n      },\n    })\n  }\n\n  // Recursively get CSS from imports\n  for (const importedFileName of chunk.imports) {\n    const importedChunk = chunksByFileName.get(importedFileName)\n    if (importedChunk) {\n      result.push(\n        ...getCSSRecursively(importedChunk, chunksByFileName, basePath),\n      )\n    }\n  }\n\n  return result\n}\n\nconst resolvedModuleId = resolveViteId(VIRTUAL_MODULES.startManifest)\nexport function startManifestPlugin(opts: {\n  clientEntry: string\n}): PluginOption {\n  let config: ResolvedConfig\n\n  return {\n    name: 'tanstack-start:start-manifest-plugin',\n    enforce: 'pre',\n\n    configResolved(resolvedConfig) {\n      config = resolvedConfig\n    },\n    resolveId: {\n      filter: { id: new RegExp(VIRTUAL_MODULES.startManifest) },\n      handler(id) {\n        if (id === VIRTUAL_MODULES.startManifest) {\n          return resolvedModuleId\n        }\n        return undefined\n      },\n    },\n    load: {\n      filter: {\n        id: new RegExp(resolvedModuleId),\n      },\n      handler(id) {\n        if (id === resolvedModuleId) {\n          if (this.environment.config.consumer !== 'server') {\n            // this will ultimately fail the build if the plugin is used outside the server environment\n            // TODO: do we need special handling for `serve`?\n            return `export default {}`\n          }\n\n          // This is the basepath for the application\n          const APP_BASE = globalThis.TSS_APP_BASE\n\n          // If we're in development, return a dummy manifest\n          if (config.command === 'serve') {\n            return `export const tsrStartManifest = () => ({\n            routes: {},\n            clientEntry: '${joinURL(APP_BASE, opts.clientEntry)}',\n          })`\n          }\n\n          // This the manifest pulled from the generated route tree and later used by the Router.\n          // i.e what's located in `src/routeTree.gen.ts`\n          const routeTreeRoutes = globalThis.TSS_ROUTES_MANIFEST.routes\n\n          // This is where hydration will start, from when the SSR'd page reaches the browser.\n          // By default, this'd be the virtual entry of `/~start/default-client-entry.tsx`, unless a custom entry is provided.\n          let entryFile: Rollup.OutputChunk | undefined\n\n          const clientBundle = globalThis.TSS_CLIENT_BUNDLE\n          const chunksByFileName = new Map<string, Rollup.OutputChunk>()\n\n          const routeChunks: Record<\n            string /** fullPath of route file **/,\n            Array<Rollup.OutputChunk>\n          > = {}\n          for (const bundleEntry of Object.values(clientBundle)) {\n            if (bundleEntry.type === 'chunk') {\n              chunksByFileName.set(bundleEntry.fileName, bundleEntry)\n              if (bundleEntry.isEntry) {\n                if (entryFile) {\n                  throw new Error(\n                    `multiple entries detected: ${entryFile.fileName} ${bundleEntry.fileName}`,\n                  )\n                }\n                entryFile = bundleEntry\n              }\n              const routePieces = bundleEntry.moduleIds.flatMap((m) => {\n                const [id, query] = m.split('?')\n                if (id === undefined) {\n                  throw new Error('expected id to be defined')\n                }\n                if (query === undefined) {\n                  return []\n                }\n                const searchParams = new URLSearchParams(query)\n                const split = searchParams.get(tsrSplit)\n\n                if (split !== null) {\n                  return {\n                    id,\n                    split,\n                  }\n                }\n                return []\n              })\n              if (routePieces.length > 0) {\n                routePieces.forEach((r) => {\n                  let array = routeChunks[r.id]\n                  if (array === undefined) {\n                    array = []\n                    routeChunks[r.id] = array\n                  }\n                  array.push(bundleEntry)\n                })\n              }\n            }\n          }\n\n          // Add preloads to the routes from the vite manifest\n          Object.entries(routeTreeRoutes).forEach(([routeId, v]) => {\n            if (!v.filePath) {\n              throw new Error(`expected filePath to be set for ${routeId}`)\n            }\n            const chunks = routeChunks[v.filePath]\n            if (chunks) {\n              chunks.forEach((chunk) => {\n                // Map the relevant imports to their route paths,\n                // so that it can be imported in the browser.\n                const preloads = chunk.imports.map((d) => {\n                  const assetPath = joinURL(APP_BASE, d)\n                  return assetPath\n                })\n\n                // Since this is the most important JS entry for the route,\n                // it should be moved to the front of the preloads so that\n                // it has the best chance of being loaded first.\n                preloads.unshift(joinURL(APP_BASE, chunk.fileName))\n\n                const cssAssetsList = getCSSRecursively(\n                  chunk,\n                  chunksByFileName,\n                  APP_BASE,\n                )\n\n                routeTreeRoutes[routeId] = {\n                  ...v,\n                  assets: [...(v.assets || []), ...cssAssetsList],\n                  preloads: [...(v.preloads || []), ...preloads],\n                }\n              })\n            }\n          })\n\n          if (!entryFile) {\n            throw new Error('No entry file found')\n          }\n          routeTreeRoutes[rootRouteId]!.preloads = [\n            joinURL(APP_BASE, entryFile.fileName),\n            ...entryFile.imports.map((d) => joinURL(APP_BASE, d)),\n          ]\n\n          // Gather all the CSS files from the entry file in\n          // the `css` key and add them to the root route\n          const entryCssAssetsList = getCSSRecursively(\n            entryFile,\n            chunksByFileName,\n            APP_BASE,\n          )\n\n          routeTreeRoutes[rootRouteId]!.assets = [\n            ...(routeTreeRoutes[rootRouteId]!.assets || []),\n            ...entryCssAssetsList,\n          ]\n\n          const recurseRoute = (\n            route: {\n              preloads?: Array<string>\n              children?: Array<any>\n            },\n            seenPreloads = {} as Record<string, true>,\n          ) => {\n            route.preloads = route.preloads?.filter((preload) => {\n              if (seenPreloads[preload]) {\n                return false\n              }\n              seenPreloads[preload] = true\n              return true\n            })\n\n            if (route.children) {\n              route.children.forEach((child) => {\n                const childRoute = routeTreeRoutes[child]!\n                recurseRoute(childRoute, { ...seenPreloads })\n              })\n            }\n          }\n\n          recurseRoute(routeTreeRoutes[rootRouteId]!)\n\n          const routesManifest = {\n            routes: routeTreeRoutes,\n            clientEntry: joinURL(APP_BASE, entryFile.fileName),\n          }\n\n          return `export const tsrStartManifest = () => (${JSON.stringify(routesManifest)})`\n        }\n\n        return undefined\n      },\n    },\n  }\n}\n"],"names":["id"],"mappings":"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"}