{"version":3,"file":"route-tree-client-plugin.js","sources":["../../../src/start-router-plugin/route-tree-client-plugin.ts"],"sourcesContent":["import path from 'node:path'\nimport * as t from '@babel/types'\nimport { generateFromAst, logDiff, parseAst } from '@tanstack/router-utils'\nimport { normalizePath } from 'vite'\nimport { deadCodeElimination } from 'babel-dead-code-elimination'\nimport { debug } from '../debug'\nimport { VITE_ENVIRONMENT_NAMES } from '../constants'\nimport type { Plugin } from 'vite'\nimport type { Config } from '@tanstack/router-generator'\n\n/**\n * This removes the server part from the generated route tree so that it can be used on the client.\n */\nexport function routeTreeClientPlugin(config: Config): Plugin {\n  const generatedRouteTreePath = normalizePath(\n    path.resolve(config.generatedRouteTree),\n  )\n\n  return {\n    name: 'tanstack-start:route-tree-client-plugin',\n    enforce: 'pre',\n    // only run this plugin in the client environment\n    applyToEnvironment: (env) => env.name === VITE_ENVIRONMENT_NAMES.client,\n    transform: {\n      filter: { id: generatedRouteTreePath },\n      handler(code, id) {\n        if (id !== generatedRouteTreePath) {\n          return null\n        }\n        if (debug) console.info(`Compiling route tree for the client`, id)\n        const ast = parseAst({ code, sourceFilename: id })\n\n        // only keep `export const routeTree = ...  `\n        const filteredBody = ast.program.body.filter((node) => {\n          if (t.isExportNamedDeclaration(node)) {\n            if (\n              node.declaration &&\n              t.isVariableDeclaration(node.declaration) &&\n              node.declaration.declarations.length === 1 &&\n              node.declaration.declarations[0] &&\n              t.isVariableDeclarator(node.declaration.declarations[0]) &&\n              t.isIdentifier(node.declaration.declarations[0].id) &&\n              node.declaration.declarations[0].id.name === 'routeTree'\n            ) {\n              return true\n            }\n            return false\n          }\n          // strip off the typescript interface & module declarations since they also reference the server routes\n          if (\n            t.isTSInterfaceDeclaration(node) ||\n            t.isTSModuleDeclaration(node)\n          ) {\n            return false\n          }\n          return true\n        })\n\n        ast.program.body = filteredBody\n\n        deadCodeElimination(ast)\n\n        const compiled = generateFromAst(ast, {\n          sourceMaps: true,\n          sourceFileName: id,\n          filename: id,\n        })\n        if (debug) {\n          logDiff(code, compiled.code)\n          console.log('Output:\\n', compiled.code, '\\n\\n')\n        }\n\n        return compiled\n      },\n    },\n  }\n}\n"],"names":[],"mappings":";;;;;;;AAaO,SAAS,sBAAsB,QAAwB;AAC5D,QAAM,yBAAyB;AAAA,IAC7B,KAAK,QAAQ,OAAO,kBAAkB;AAAA,EACxC;AAEO,SAAA;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA;AAAA,IAET,oBAAoB,CAAC,QAAQ,IAAI,SAAS,uBAAuB;AAAA,IACjE,WAAW;AAAA,MACT,QAAQ,EAAE,IAAI,uBAAuB;AAAA,MACrC,QAAQ,MAAM,IAAI;AAChB,YAAI,OAAO,wBAAwB;AAC1B,iBAAA;AAAA,QAAA;AAET,YAAI,MAAO,SAAQ,KAAK,uCAAuC,EAAE;AACjE,cAAM,MAAM,SAAS,EAAE,MAAM,gBAAgB,IAAI;AAGjD,cAAM,eAAe,IAAI,QAAQ,KAAK,OAAO,CAAC,SAAS;AACjD,cAAA,EAAE,yBAAyB,IAAI,GAAG;AACpC,gBACE,KAAK,eACL,EAAE,sBAAsB,KAAK,WAAW,KACxC,KAAK,YAAY,aAAa,WAAW,KACzC,KAAK,YAAY,aAAa,CAAC,KAC/B,EAAE,qBAAqB,KAAK,YAAY,aAAa,CAAC,CAAC,KACvD,EAAE,aAAa,KAAK,YAAY,aAAa,CAAC,EAAE,EAAE,KAClD,KAAK,YAAY,aAAa,CAAC,EAAE,GAAG,SAAS,aAC7C;AACO,qBAAA;AAAA,YAAA;AAEF,mBAAA;AAAA,UAAA;AAGT,cACE,EAAE,yBAAyB,IAAI,KAC/B,EAAE,sBAAsB,IAAI,GAC5B;AACO,mBAAA;AAAA,UAAA;AAEF,iBAAA;AAAA,QAAA,CACR;AAED,YAAI,QAAQ,OAAO;AAEnB,4BAAoB,GAAG;AAEjB,cAAA,WAAW,gBAAgB,KAAK;AAAA,UACpC,YAAY;AAAA,UACZ,gBAAgB;AAAA,UAChB,UAAU;AAAA,QAAA,CACX;AACD,YAAI,OAAO;AACD,kBAAA,MAAM,SAAS,IAAI;AAC3B,kBAAQ,IAAI,aAAa,SAAS,MAAM,MAAM;AAAA,QAAA;AAGzC,eAAA;AAAA,MAAA;AAAA,IACT;AAAA,EAEJ;AACF;"}